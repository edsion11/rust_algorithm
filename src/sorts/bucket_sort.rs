
/// Bucket sort from https://chercher.tech/rust/bucket-sort-rust

pub fn bucket_sort<H, F, T>(arr: &mut [T], hasher: F)
    where
        H: Ord, // compare trait
        F: Fn(&T) -> H, // 闭包
        T: Ord + Clone,
{
    // 1. 初始化桶struct
    let mut buckets: Vec<Bucket<H, T>> = Vec::new();

    // 2. 遍历数组中每个元素
    for value in arr.iter() {
        // 2.1 桶中每个元素是一个hash，根据传入的hasher计算所得
        let hash = hasher(&value);

        // 2.2 搜索是否有相关hash值的元素
        let value = value.clone();
        match buckets.binary_search_by(|bucket| bucket.hash.cmp(&hash)) {
            // If exists, push the value to the bucket.
            Ok(index) => buckets[index].values.push(value),
            // If none, create and new bucket and insert value in.
            Err(index) => buckets.insert(index, Bucket::new(hash, value)),
        }
    }

    // 3. 遍历所有的桶并且扁平化合并
    let ret = buckets
        .into_iter()
        .flat_map(|mut bucket| {
            bucket.values.sort(); // We use built-in sorting here.
            bucket.values
        })
        .collect::<Vec<T>>();

    // 4. Clone back to original array.
    arr.clone_from_slice(&ret);
}

/// Bucket to store elements.

struct Bucket<H, T> {
    hash: H,
    values: Vec<T>,
}

impl<H, T> Bucket<H, T> {
    /// Create a new bucket and insert its first value.
    ///
    /// * `hash` - Hash value generated by hasher param of `bucket_sort`.
    /// * `value` - Value to be put in the bucket.
    pub fn new(hash: H, value: T) -> Bucket<H, T> {
        Bucket {
            hash,
            values: vec![value],
        }
    }
}
#[test]
fn test_bucket(){
    fn bucket_sort_(arr: &mut [i32]) {
        bucket_sort(arr, |int| int / 4)
    }
    let mut base_array = [4,3,2,1,6,4,2,3,6,7,4,1,2,5,6,3,2,1,1,5,6,6,1,2,6,6,4,1,12,5,6].to_vec();
    bucket_sort_(&mut base_array);
    println!("sort: {:?}", base_array);
}

// #[cfg(test)]
//
// mod base {
//     use super::*;
//     fn bucket_sort_(arr: &mut [i32]) {
//         bucket_sort(arr, |int| int / 4);
//     }
//     base_cases!(bucket_sort_);
// }
//
// #[cfg(test)]
//
// mod stability {
//     use super::*;
//     fn bucket_sort_(arr: &mut [(i32, i32)]) {
//         bucket_sort(arr, |t| t.0 / 4);
//     }
//     stability_cases!(bucket_sort_);
// }